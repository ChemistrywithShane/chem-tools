<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mole Master & Titration Lab Wireframes</title>
<style>
body { font-family: Arial, sans-serif; background: #f7f7f7; margin: 20px; }
.tool { background: white; border-radius: 12px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 40px; padding: 20px; }
h2 { margin-top: 0; color: #003366; }
.section { margin: 20px 0; }
.box { border: 2px dashed #aaa; border-radius: 8px; padding: 15px; margin: 10px 0; background: #fafafa; }
.slider { background: #eee; height: 20px; border-radius: 10px; margin: 10px 0; position: relative; }
.slider::after { content: "‚óâ"; position: absolute; left: 40%; top: -5px; }
.table { border-collapse: collapse; width: 100%; margin-top: 10px; }
.table th, .table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
.teacher-controls { background: #eef6ff; border: 1px solid #99c2ff; padding: 10px; margin-top: 15px; border-radius: 6px; }
.graph { border: 2px dotted #666; height: 150px; border-radius: 6px; text-align: center; line-height: 150px; color: #999; }
/* --- Titration visuals --- */
.bench { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
.panel { flex: 1 1 320px; background:#fafafa; border:2px dashed #aaa; border-radius:8px; padding:12px; }


.burette-scale { position:absolute; left:8px; top:6px; bottom:6px; width:10px; background:repeating-linear-gradient(to bottom, transparent 0 18px, #999 18px 19px); opacity:.7; }
.burette-fill { position:absolute; right:0; bottom:0; width:100%; background:#cfe3ff; border-bottom-left-radius:4px; border-bottom-right-radius:4px; }

.endpoint-bar { height:10px; background:repeating-linear-gradient(90deg,#ccc 0 10px,#eee 10px 20px); border-radius:6px; margin:8px 0; }
.dot { display:inline-block; min-width:12px; min-height:12px; border-radius:50%; border:1px solid #999; vertical-align:middle; margin-right:6px; }

/* Drop now uses viewport coordinates and flies from spout to flask */
.drop {
  position: fixed;         /* positioned relative to the viewport */
  width: 10px;
  height: 14px;
  background: #cfe3ff;
  border-radius: 50% 50% 60% 60%/50% 50% 70% 70%;
  pointer-events: none;
  z-index: 9999;
  opacity: 1;
  transform: translate(-50%, -50%);
  transition: top 0.7s linear, left 0.7s linear, opacity 0.2s ease-out;
}
  /* --- Lab layout --- */
.lab-grid {
  display: grid;
  grid-template-columns: 340px 1fr;  /* controls | big visuals */
  gap: 18px;
  align-items: start;
}

.visuals {
  display: block;   /* one big area for the SVG */
}

/* Card look for controls */
.card {
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 14px;
  box-shadow: 0 3px 10px rgba(0,0,0,0.05);
}

/* Right visuals area: burette + flask */

.visuals .panel {
  border: 1px dashed #cbd5e1;
  border-radius: 10px;
  background: #fafafa;
}

/* Small section titles */
.panel-title {
  font-weight: 700;
  margin: 6px 0 10px;
}

/* Make the left control panel a little sticky while scrolling */
.sticky-ctrl {
  position: sticky;
  top: 12px;
}


.readout { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#fff; border:1px solid #ddd; padding:4px 8px; border-radius:6px; display:inline-block; }
.ctrl-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
/* --- Impact ripple in the flask --- */
.ripple {
  position: absolute;            /* lives inside the flask (clipped) */
  width: 6px; height: 6px;
  border: 2px solid rgba(0,0,0,0.18);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0.2);
  pointer-events: none;
  animation: ripple 0.6s ease-out forwards;
}
@keyframes ripple {
  to { transform: translate(-50%, -50%) scale(3.6); opacity: 0; }
}
/* Continuous stream from spout to liquid */
.stream {
  position: fixed;      /* viewport coords like .drop */
  width: 6px;
  background: linear-gradient(to bottom, rgba(180,210,255,0.9), rgba(180,210,255,0.4));
  border-radius: 3px;
  pointer-events: none;
  z-index: 9998;
  opacity: 0;
  transition: opacity .15s ease;
}

/* === Cartoon SVG styling (added) === */
:root{
  --svg-line:#374151;    /* outline */
  --svg-accent:#111827;  /* ticks/tap */
  --svg-glass:#ffffff;   /* glass interior */
  --svg-shadow:#e5e7eb;  /* subtle shading */
}
.svg-line   { stroke:var(--svg-line);   stroke-width:3.2; stroke-linecap:round; stroke-linejoin:round; fill:none; }
.svg-glass  { fill:var(--svg-glass);    stroke:var(--svg-line); stroke-width:3.2; stroke-linecap:round; stroke-linejoin:round; }
.svg-metal  { fill:#fff;                 stroke:var(--svg-accent); stroke-width:3.2; }
.svg-tick   { stroke:var(--svg-accent);  stroke-width:2; }
/* keep outlines thick even when the SVG scales down */
.svg-line, .svg-glass, .svg-metal, .svg-tick { vector-effect: non-scaling-stroke; }

</style>
</head>
<body>


<!-- Mole Master -->
<div class="tool">
<h2>Wireframe: Mole Master</h2>


<div class="section">
<h3>Equation Input</h3>
<label for="mm-eq">Type an equation:</label>
<input id="mm-eq" value="H2 + O2 -> H2O" style="width: 60%; max-width: 480px;">
<button id="mm-balance-btn">Auto-balance</button>
<div id="mm-balance-result" class="box" style="margin-top:8px;">Balanced equation will appear here‚Ä¶</div>
That gives you:


<div class="section">
<h3>Recipe View</h3>
<div class="box">
- Bars for moles / mass / volume<br>
- Visual ‚Äúcake recipe‚Äù layout
</div>
</div>


<div class="section">
<h3>Adjust Quantities</h3>
<div>
  <label>Reactant amount (g): <b id="mm-reactant-val">50</b></label><br>
  <input id="mm-reactant" type="range" min="0" max="100" value="50" step="1" style="width:100%;">
</div>
<div style="margin-top:10px;">
  <label>Product target (g): <b id="mm-product-val">40</b></label><br>
  <input id="mm-product" type="range" min="0" max="100" value="40" step="1" style="width:100%;">
</div>
<div id="mm-limit-msg" class="box" style="margin-top:10px;">
  Move the sliders. I‚Äôll tell you which side is limiting.
</div>
<div class="box">Dynamic bar charts update ‚Üí Limiting Reactant Highlighted</div>
</div>


<div class="section teacher-controls">
<h3>Teacher Controls</h3>
- Lock inputs (mass, conc)<br>
- Add uncertainty overlay<br>
- Export as CSV
</div>


<div class="section">
<h3>Output</h3>
<div class="box">[ Results panel: Leftover, % yield, Atom economy ]</div>
</div>
</div>


<!-- Titration Lab -->
<div class="tool">
<h2>Wireframe: Titration Lab</h2>


<div class="section">
<h3>Lab Bench View</h3>
<div class="box">
[ Burette graphic (left) ] ‚Üí [ Conical flask on white tile (centre) ] ‚Üí [ Pipette control (right) ]<br>
Indicator dropdown: Phenolphthalein / Methyl Orange / Litmus
</div>
</div>


<div class="section">
<h3>Run Titration</h3>

<!-- New two-column layout -->
<div class="lab-grid">

  <!-- LEFT column: all controls -->
  <div class="card sticky-ctrl" id="controls">
    <div class="panel-title">Controls</div>

    <!-- Indicator -->
    <div style="margin-bottom:8px;">
      <b>Indicator:</b>
      <select id="ind-select">
        <option value="phenolphthalein" selected>Phenolphthalein (pink ‚Üí colourless)</option>
        <option value="methylorange">Methyl orange (red ‚Üí orange ‚Üí yellow)</option>
      </select>
    </div>

    <!-- Endpoint marker bar (optional visual divider) -->
    <div class="endpoint-bar" title="Endpoint marker"></div>

    <!-- Chemistry setup -->
    <div class="ctrl-row" style="margin:6px 0; gap:14px;">
      <label>Acid in burette:
        <input id="conc-acid" type="number" step="0.01" value="0.10" style="width:80px;"> mol&nbsp;dm‚Åª¬≥
      </label>
    </div>

    <div class="ctrl-row" style="gap:14px;">
      <label>Base in flask:
        <input id="conc-base" type="number" step="0.01" value="0.10" style="width:80px;"> mol&nbsp;dm‚Åª¬≥
      </label>
      <label>Flask vol:
        <input id="flask-vol" type="number" step="0.1" value="25.0" style="width:80px;"> cm¬≥
      </label>
    </div>

    <div class="ctrl-row" style="margin:6px 0;">
      <label>
        <input id="use-conc-endpoint" type="checkbox" checked>
        Use concentrations to set endpoint (overrides table mean)
      </label>
    </div>

    <div class="ctrl-row" style="margin:4px 0;">
      <span>Endpoint: <span class="readout" id="endpoint-out">‚Äî</span> cm¬≥
        <small style="opacity:.7">(<span id="endpoint-source">from concentrations</span>)</small>
      </span>
    </div>

    <!-- Flow rate -->
    <div class="ctrl-row" style="margin-top:6px;">
      <label for="flow-rate"><b>Flow rate</b> (drops/s): <span class="readout" id="flow-out">8</span></label>
      <input id="flow-rate" type="range" min="1" max="20" value="8" step="1" style="width:240px;">
    </div>

    <!-- Burette volume + buttons -->
    <div style="margin-top:8px;">
      <label for="bur-vol"><b>Burette volume added</b> (cm¬≥): <span class="readout" id="bur-vol-out">0.00</span></label>
      <input id="bur-vol" type="range" min="0" max="30" value="0" step="0.05" style="width:100%;">
    </div>

    <div class="ctrl-row" style="margin-top:6px;">
      <button id="drip-1">Drip 1 drop (‚âà0.05 cm¬≥)</button>
      <button id="drip-hold">Hold to drip</button>
      <button id="reset-bur">Reset</button>
    </div>

    <!-- Live colour dot + pH readout -->
    <div class="ctrl-row" style="margin:6px 0;">
      <span class="dot" id="dot-color" style="background:#ffc0de;"></span>
      Flask colour ‚Ä¢ pH (approx): <span class="readout" id="ph-read">~13</span>
    </div>
    
    <hr style="margin:10px 0; border:none; border-top:1px solid #e5e7eb;">
<div style="margin-top:6px;"><b>pH vs volume added</b></div>
<canvas id="ph-graph" width="320" height="220"></canvas>
  </div>

  <!-- RIGHT column: lab visuals (burette + flask + graph) -->
  <div class="visuals">
    <div class="visuals-grid">

  <!-- Cartoon burette + flask SVG (unlabelled; animation-ready) -->
<svg id="lab-svg" viewBox="0 0 1100 700" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:auto;display:block">
  <!-- optional stand + tile (nice for layout; hide if you want) -->
  <g id="stand">
    <rect x="180" y="620" width="320" height="24" rx="6" class="svg-glass"/>
    <rect x="190" y="628" width="300" height="10" rx="4" fill="var(--svg-shadow)"/>
    <rect x="330" y="120" width="18" height="520" rx="9" class="svg-metal"/>
  </g>
  <g id="tile">
    <rect x="410" y="600" width="200" height="20" rx="6" class="svg-glass"/>
    <rect x="420" y="607" width="180" height="7" rx="3" fill="var(--svg-shadow)"/>
  </g>

  <!-- BURETTE -->
  <g id="burette" transform="translate(500,40)">
  <!-- tube outline -->
  <rect x="0" y="0" width="44" height="470" rx="12" class="svg-glass"/>
  <rect id="bur-fill-svg" x="2" y="2" width="40" height="430" rx="10" fill="#cfe3ff" opacity=".6"/>

  <!-- ticks (inside the tube) -->
  <g id="buretteTicks" class="svg-tick">
    <line x1="4" y1="20"  x2="18" y2="20"/>
    <line x1="4" y1="70"  x2="18" y2="70"/>
    <line x1="4" y1="120" x2="18" y2="120"/>
    <line x1="4" y1="170" x2="18" y2="170"/>
    <line x1="4" y1="220" x2="18" y2="220"/>
    <line x1="4" y1="270" x2="18" y2="270"/>
    <line x1="4" y1="320" x2="18" y2="320"/>
    <line x1="4" y1="370" x2="18" y2="370"/>
    <line x1="4" y1="420" x2="18" y2="420"/>
  </g>

  <!-- stopcock block (now INSIDE burette group) -->
  <g id="stopcock" transform="translate(0,470)">
    <rect x="4" y="-30" width="52" height="32" rx="8" class="svg-metal"/>
    <path d="M56,-16 H95 a8,8 0 0 1 8,8 v0 a8,8 0 0 1 -8,8 H56 Z" class="svg-metal"/>
    <g id="handle" transform="translate(26,-34)">
      <line x1="0" y1="0" x2="0" y2="-10" class="svg-line"/>
      <line x1="-12" y1="-10" x2="12" y2="-10" class="svg-line"/>
    </g>
  </g>

  <!-- vertical tip and hit-point -->
  <path d="M22,470 v70" class="svg-glass"/>
  <circle id="spout-tip" cx="22" cy="540" r="3" fill="transparent"/>
</g>


  <!-- FLASK (cartoon) -->
  <g id="flask" transform="translate(500,480)">
    <!-- body -->
    <path class="svg-glass" d="M-120,170 H120 a12,12 0 0 0 11-18 l-46-96 c-4-8 -6-16 -6-25 V-10 c0-6 -5-11 -11-11 h-14 c-6,0 -11-5 -11-11 v-18 c0-6 -5-11 -11-11 h-36 c-6,0 -11,5 -11,11 v18 c0,6 -5,11 -11,11 h-14 c-6,0 -11,5 -11,11 v45 c0,9 -2,17 -6,25 l-46,96 a12,12 0 0 0 11,18 Z"/>
    <!-- clipping rectangle controls the fill height -->
    <clipPath id="liq-clip">
      <rect id="liq-level" x="-120" y="170" width="240" height="0" />
    </clipPath>
    <!-- liquid shape (colour via fill; height via clip) -->
    <path id="flask-liquid" d="M-118,120 q45,-12 118,-12 q73,0 118,12 v60 h-236 Z"
          fill="#ffd" clip-path="url(#liq-clip)"/>
  </g>
</svg>
   

     

    </div>
  </div>

</div>


<h3>Data Table</h3>
<table class="table" id="tit-table">
  <tr><th>Trial</th><th>Initial (cm¬≥)</th><th>Final (cm¬≥)</th><th>Titre (cm¬≥)</th></tr>
  <tr>
    <td>Rough</td>
    <td><input value="0.00" class="tit-in" data-row="0" data-type="init"></td>
    <td><input value="23.80" class="tit-in" data-row="0" data-type="final"></td>
    <td id="tit-titre-0">23.80</td>
  </tr>
  <tr>
    <td>1</td>
    <td><input value="0.00" class="tit-in" data-row="1" data-type="init"></td>
    <td><input value="23.40" class="tit-in" data-row="1" data-type="final"></td>
    <td id="tit-titre-1">23.40</td>
  </tr>
  <tr>
    <td>2</td>
    <td><input value="0.00" class="tit-in" data-row="2" data-type="init"></td>
    <td><input value="23.50" class="tit-in" data-row="2" data-type="final"></td>
    <td id="tit-titre-2">23.50</td>
  </tr>
</table>
<div class="box">Mean (Trials 1 & 2): <b id="tit-mean">23.45</b> cm¬≥</div>
<script>
/* === Mole Master: Auto-balance demo === */
document.getElementById('mm-balance-btn').addEventListener('click', () => {
  const eq = document.getElementById('mm-eq').value.trim().replace(/\s+/g,'');
  const out = document.getElementById('mm-balance-result');
  if (eq === 'H2+O2->H2O' || eq === 'H2+O2=>H2O') {
    out.textContent = '2H‚ÇÇ + O‚ÇÇ ‚Üí 2H‚ÇÇO';
  } else {
    out.textContent = 'This demo only balances water right now üòä Try: H2 + O2 -> H2O';
  }
});

/* === Mole Master sliders === */
const rSlide = document.getElementById('mm-reactant');
const pSlide = document.getElementById('mm-product');
const rVal = document.getElementById('mm-reactant-val');
const pVal = document.getElementById('mm-product-val');
const limitMsg = document.getElementById('mm-limit-msg');
function updateMM() {
  rVal.textContent = rSlide.value;
  pVal.textContent = pSlide.value;
  const r = Number(rSlide.value), p = Number(pSlide.value);
  if (r === 0 && p === 0) limitMsg.textContent = 'Both are zero ‚Äî nothing will happen yet!';
  else if (r === p) limitMsg.textContent = 'Perfectly matched ‚Äî no leftovers üéâ';
  else if (r < p) limitMsg.textContent = 'Reactant is limiting (you need more reactant to hit that product target).';
  else limitMsg.textContent = 'Product target is low ‚Äî you will have leftover reactant.';
}
rSlide.addEventListener('input', updateMM);
pSlide.addEventListener('input', updateMM);
updateMM();

/* === Titration: auto-calc titres & mean === */
function twoDp(x){ return Number(x).toFixed(2); }
function recalcTitration() {
  for (let row = 0; row <= 2; row++) {
    const init = document.querySelector(`.tit-in[data-row="${row}"][data-type="init"]`).value;
    const fin  = document.querySelector(`.tit-in[data-row="${row}"][data-type="final"]`).value;
    const titre = twoDp(Number(fin) - Number(init));
    document.getElementById(`tit-titre-${row}`).textContent = titre;
  }
  const t1 = parseFloat(document.getElementById('tit-titre-1').textContent);
  const t2 = parseFloat(document.getElementById('tit-titre-2').textContent);
  document.getElementById('tit-mean').textContent = twoDp((t1 + t2) / 2);
}
document.querySelectorAll('.tit-in').forEach(inp => {
  inp.addEventListener('input', recalcTitration);
});
recalcTitration();
/* ===== Titration: burette drip + colour-changing flask ===== */

// Grab controls
const burSlider = document.getElementById('bur-vol');
const burOut = document.getElementById('bur-vol-out');
const burFill = document.getElementById('bur-fill');
const flask = document.getElementById('flask');
const liquid = document.getElementById('liquid');
const endOut = document.getElementById('endpoint-out');
const phOut = document.getElementById('ph-read');
const dotColor = document.getElementById('dot-color');
const dripBtn = document.getElementById('drip-1');
const resetBtn = document.getElementById('reset-bur');
const indSelect = document.getElementById('ind-select');
const flowSlider = document.getElementById('flow-rate');
const flowOut = document.getElementById('flow-out');
const concAcid   = document.getElementById('conc-acid');   // mol dm^-3
const concBase   = document.getElementById('conc-base');   // mol dm^-3
const flaskVol   = document.getElementById('flask-vol');   // cm^3
const useConcEP  = document.getElementById('use-conc-endpoint');
const epSource   = document.getElementById('endpoint-source');
// === NEW: SVG elements ===
const svgBurFill = document.getElementById('bur-fill-svg');
const svgHandle  = document.getElementById('handle');
const spoutTip   = document.getElementById('spout-tip');
const flaskGroup = document.getElementById('flask');       // <g> group
const flaskLiquid= document.getElementById('flask-liquid'); // path (colour)
const liqRect    = document.getElementById('liq-level');    // clip rect controlling height  
// Convert an SVG element‚Äôs local point (x,y) to viewport/screen coords
function svgToScreen(elem, x, y) {
  const svg = elem.ownerSVGElement || elem;   // root <svg>
  const pt = svg.createSVGPoint();
  pt.x = x; pt.y = y;
  const ctm = elem.getScreenCTM();
  const p = pt.matrixTransform(ctm);
  return { x: p.x, y: p.y };
}

// --- flow / pour constants ---
const CONT_THRESHOLD = 15;   // ‚â• this rate = continuous stream
const BASE_STEP = 0.05;      // ~0.05 cm¬≥ per ‚Äúdrop‚Äù at low flow

// --- continuous pour support ---
let streamEl = null;  // the DOM element for the visible stream
let pourRAF = null;   // requestAnimationFrame handle while pouring

// Use the mean from your table as the endpoint (nice link!)
function getEndpoint() {
  const el = document.getElementById('tit-mean');
  const v = el ? parseFloat(el.textContent) : 23.50;
  return isFinite(v) ? v : 23.50;
}
  let ENDPOINT = getEndpoint();            // <-- call the function
if (endOut) endOut.textContent = ENDPOINT.toFixed(2);

  
// Endpoint from concentrations (assume 1:1 strong acid/base): Va(cm3) = (Cb * Vb(cm3)) / Ca
function endpointFromConc() {
  const Ca = Math.max(0.0001, parseFloat(concAcid.value));  // avoid /0
  const Cb = Math.max(0, parseFloat(concBase.value));
  const Vb = Math.max(0, parseFloat(flaskVol.value));       // cm^3
  return (Cb * Vb) / Ca; // cm^3
}
function applyEndpoint() {
  const useBox = (typeof useConcEP !== 'undefined' && useConcEP) ? useConcEP.checked : false;
  if (useBox) {
    ENDPOINT = endpointFromConc();
    if (endOut) endOut.textContent = ENDPOINT.toFixed(2);
    if (epSource) epSource.textContent = 'from concentrations';
  } else {
    ENDPOINT = getEndpoint();
    if (endOut) endOut.textContent = ENDPOINT.toFixed(2);
    if (epSource) epSource.textContent = 'from table mean';
  }
  updateBuretteUI();
  if (typeof drawPHGraph === 'function') drawPHGraph();
}

// Simple pH approximation for strong acid/strong base titration curve.
// We just want the "S-shape" to teach the idea; not lab-accurate.
function approxPH(added) {
  // Map 0..(2*endpoint) into ~13..1 with a steep switch around endpoint
  const e = ENDPOINT;
  const x = (added - e) / (e * 0.08);  // 8% of endpoint makes a steep region
  const sig = 1 / (1 + Math.exp(-x));  // 0..1
  const ph = 13 - sig * 12;            // ~13 high, ~1 low
  return Math.max(1, Math.min(13, ph));
}
  function drawPHGraph() {
  const cvs = document.getElementById('ph-graph');
  if (!cvs) return;
  const ctx = cvs.getContext('2d');

  const W = cvs.width, H = cvs.height;
  ctx.clearRect(0,0,W,H);

  // Margins
  const mL = 36, mR = 10, mT = 10, mB = 28;
  const plotW = W - mL - mR, plotH = H - mT - mB;

  // X range: 0 .. 1.5 * ENDPOINT
  const xMax = Math.max(5, ENDPOINT * 1.5);
  const xToPx = x => mL + (x / xMax) * plotW;
  const yToPx = ph => mT + (1 - (ph - 1) / 12) * plotH; // ph 1..13 -> bottom..top

  // Axes
  ctx.strokeStyle = '#999'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(mL, mT); ctx.lineTo(mL, mT+plotH); ctx.lineTo(mL+plotW, mT+plotH); ctx.stroke();

  // Ticks & labels
  ctx.fillStyle = '#666'; ctx.font = '12px sans-serif';
  for (let pH = 1; pH <= 13; pH += 2) {
    const y = yToPx(pH);
    ctx.beginPath(); ctx.moveTo(mL-4,y); ctx.lineTo(mL,y); ctx.stroke();
    ctx.fillText(pH.toString(), 4, y+4);
  }
  for (let i = 0; i <= 5; i++) {
    const x = (i/5)*xMax;
    const xp = xToPx(x), y0 = mT+plotH;
    ctx.beginPath(); ctx.moveTo(xp, y0); ctx.lineTo(xp, y0+4); ctx.stroke();
    ctx.fillText((Math.round(x*10)/10).toString(), xp-6, y0+16);
  }

  // Curve
  ctx.strokeStyle = '#2b6'; ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i <= 200; i++) {
    const x = (i/200)*xMax;
    const ph = approxPH(x);
    const xp = xToPx(x), yp = yToPx(ph);
    if (i===0) ctx.moveTo(xp, yp); else ctx.lineTo(xp, yp);
  }
  ctx.stroke();

  // Mark ENDPOINT vertical
  const epX = xToPx(ENDPOINT);
  ctx.strokeStyle = '#bbb'; ctx.lineWidth = 1; ctx.setLineDash([4,4]);
  ctx.beginPath(); ctx.moveTo(epX, mT); ctx.lineTo(epX, mT+plotH); ctx.stroke();
  ctx.setLineDash([]);

  // Current volume marker
  const v = parseFloat(burSlider.value);
  const vp = xToPx(v), pNow = approxPH(v), yp = yToPx(pNow);
  ctx.fillStyle = '#c33';
  ctx.beginPath(); ctx.arc(vp, yp, 3, 0, Math.PI*2); ctx.fill();
}

function updateFlowLabel() {
  if (!flowSlider) return;
  flowOut.textContent = flowSlider.value;
}
updateFlowLabel();
flowSlider.addEventListener('input', updateFlowLabel);
function updateTapVisual(rate) {
  if (!svgHandle) return;                                 // SVG not present yet
  const r = Math.max(0, Math.min(20, parseInt(rate || 0, 10)));
  const angle = (r / 20) * 85;                            // 0..85¬∞
  // Rotate around the handle‚Äôs own pivot and preserve its translate
  svgHandle.setAttribute('transform', `translate(26,-34) rotate(${angle})`);
}


// Colour model per indicator
function colourForIndicator(ph, indicator) {
  if (indicator === 'phenolphthalein') {
    // Pink above ~8.2, colourless below ~8.2
    if (ph >= 10.0) return { bg:'#ffc0de', dot:'#ffc0de' };        // strong pink
    if (ph >= 8.2)  return { bg:'#ffe0ee', dot:'#ffd2e6' };        // pale pink
    return { bg:'#f7f7f7', dot:'#f7f7f7' };                        // colourless
  } else {
    // Methyl orange: red (<3.1), orange (3.1..4.4), yellow (>4.4)
    if (ph < 3.1)   return { bg:'#ffb3a8', dot:'#ff8f80' };        // red-ish
    if (ph < 4.4)   return { bg:'#ffd19a', dot:'#ffb347' };        // orange
    return { bg:'#fff7a6', dot:'#ffe34d' };                        // yellow
  }
}

// Update the whole visual state
function updateBuretteUI() {
  const v = parseFloat(burSlider.value);
  burOut.textContent = v.toFixed(2);

  // Burette "fullness" (height of the inner rect decreases as volume added increases)
  if (svgBurFill) {
  const max = parseFloat(burSlider.max) || 30;
  const tubeInnerH = 430;                    // height of bur-fill-svg in SVG
  const h = Math.max(0, tubeInnerH * (1 - v / max));
  const y = 2 + (tubeInnerH - h);            // move top down as it empties
  svgBurFill.setAttribute('height', h.toFixed(1));
  svgBurFill.setAttribute('y', y.toFixed(1));
}

  // Flask liquid level: control clip-rect height (0 at empty; grows downward)
  if (liqRect) {
    const basePct = 0.35; // 35% baseline
    const extraPct = Math.min(0.20, (v / ENDPOINT) * 0.20);
    const boxH = 170;     // from SVG (liquid area height; matches clip region area)
    const hPx = (basePct + extraPct) * boxH;
    liqRect.setAttribute('height', hPx.toFixed(1));
    liqRect.setAttribute('y', (170 - hPx).toFixed(1)); // keep fill from bottom upwards
  }

  // pH + colour
  const ph = approxPH(v);
  phOut.textContent = '~' + ph.toFixed(1);
  const col = colourForIndicator(ph, indSelect.value);
  if (flaskLiquid) flaskLiquid.setAttribute('fill', col.bg);
  dotColor.style.backgroundColor = col.dot;
}

  // Create the (single) stream element if needed
function ensureStreamEl() {
  if (streamEl) return streamEl;
  streamEl = document.createElement('div');
  streamEl.className = 'stream';
  document.body.appendChild(streamEl);
  return streamEl;
}

// Position the stream from the spout tip down to the current liquid surface
function positionStream() {
  if (!spoutTip || !liqRect) return;

  // start: spout tip centre
  const sx = +spoutTip.getAttribute('cx');
  const sy = +spoutTip.getAttribute('cy');
  const start = svgToScreen(spoutTip, sx, sy);

  // end: liquid surface centre (top edge of clip rect)
  const lx = +liqRect.getAttribute('x');
  const lw = +liqRect.getAttribute('width');
  const ly = +liqRect.getAttribute('y');
  const end = svgToScreen(liqRect, lx + lw/2, ly);

  const el = ensureStreamEl();
  el.style.left   = `${start.x - 3}px`;
  el.style.top    = `${start.y}px`;
  el.style.height = `${Math.max(6, end.y - start.y)}px`;
}

// Show/hide the stream with a quick fade
function showStream(show) {
  ensureStreamEl();
  positionStream();
  streamEl.style.opacity = show ? 1 : 0;
}

// Create a falling drop animation
function spawnDrop(step = 0.05) {
  if (!spoutTip || !liqRect) return;

  // start at spout tip
  const sx = +spoutTip.getAttribute('cx');
  const sy = +spoutTip.getAttribute('cy');
  const start = svgToScreen(spoutTip, sx, sy);

  // target = liquid surface centre
  const lx = +liqRect.getAttribute('x');
  const lw = +liqRect.getAttribute('width');
  const ly = +liqRect.getAttribute('y');
  const target = svgToScreen(liqRect, lx + lw/2, ly);

  const drop = document.createElement('div');
  drop.className = 'drop';
  document.body.appendChild(drop);

  const size = Math.min(22, 8 + step * 200);
  drop.style.width  = size + 'px';
  drop.style.height = (size * 1.3) + 'px';
  drop.style.left = `${start.x}px`;
  drop.style.top  = `${start.y}px`;

  requestAnimationFrame(() => {
    drop.style.left = `${target.x}px`;
    drop.style.top  = `${target.y - 2}px`;
  });

  drop.addEventListener('transitionend', () => {
    spawnRipple(target.x, target.y);
    drop.style.opacity = '0';
    setTimeout(() => drop.remove(), 200);
  }, { once: true });
}


// Buttons
dripBtn.addEventListener('click', () => {
  const step = parseFloat(burSlider.step) || 0.05;
  const newV = Math.min(parseFloat(burSlider.max), parseFloat(burSlider.value) + step);
  burSlider.value = newV.toString();
  spawnDrop();
  updateBuretteUI();
  drawPHGraph();
});
// Hold-to-drip: press and hold to drip repeatedly
const holdBtn = document.getElementById('drip-hold');
let dripTimer = null;

function dripOnce() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);        // drops/sec
  const step = BASE_STEP * (1 + (rate - 1) / 10);                        // bigger glugs at higher rate

  const newV = Math.min(parseFloat(burSlider.max), parseFloat(burSlider.value) + step);
  if (newV === parseFloat(burSlider.value)) return; // at max
  burSlider.value = newV.toString();
  spawnDrop(step);                                                      // pass size for visuals
  updateBuretteUI();
  drawPHGraph();
}



// Compute + set the interval from the current flow rate
function setDripIntervalFromRate() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8); // drops/sec
  const period = 1000 / rate; // ms per drop
  if (dripTimer) clearInterval(dripTimer);
  dripTimer = setInterval(dripOnce, period);
}

function startHold() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);
  updateTapVisual(rate);
  // High flow ‚Üí continuous stream using requestAnimationFrame
  if (rate >= CONT_THRESHOLD) {
    if (pourRAF) return;            // already pouring
    showStream(true);

    let last = performance.now();
    const stepPerDrop = BASE_STEP * (1 + (rate - 1) / 10);
    const dropsPerSec = rate;

    const tick = (now) => {
      const dt = (now - last) / 1000;   // seconds since last frame
      last = now;

      // Volume increment this frame
      const dv = dropsPerSec * stepPerDrop * dt;
      const vNow = parseFloat(burSlider.value);
      const vMax = parseFloat(burSlider.max);
      const vNew = Math.min(vMax, vNow + dv);

      burSlider.value = vNew.toFixed(3);
      updateBuretteUI();
      drawPHGraph();

      // Keep the stream aligned to spout ‚Üí liquid (with tiny jitter)
      positionStream();
      if (streamEl) {
        const j = (Math.random() - 0.5) * 2; // ¬±1 px wobble
        streamEl.style.transform = `translateX(${j}px)`;
      }

      if (vNew >= vMax || !pourRAF) {
        stopHold();                   // stop if maxed or cancelled
        return;
      }
      pourRAF = requestAnimationFrame(tick);
    };

    pourRAF = requestAnimationFrame(tick);
    return;
  }

  // Low/medium flow ‚Üí discrete drops via interval
  setDripIntervalFromRate();
}

function stopHold() {
  // stop timers/RAF ...
  if (dripTimer) { clearInterval(dripTimer); dripTimer = null; }
  if (pourRAF) { cancelAnimationFrame(pourRAF); pourRAF = null; }
  showStream(false);

  updateTapVisual(0);                   // <--- closes the tap
}


// Mouse + touch support
holdBtn.addEventListener('mousedown', startHold);
holdBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive: false });
['mouseup','mouseleave','touchend','touchcancel'].forEach(ev => {
  holdBtn.addEventListener(ev, stopHold);
});

// If the flow slider changes while holding, retune the interval live
flowSlider.addEventListener('input', () => {
  updateFlowLabel();
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);
  updateTapVisual(rate);                // <--- add this line

  // If we're currently holding (either mode), switch modes on the fly
  if (dripTimer || pourRAF) {
    stopHold();
    startHold();
  }
});



resetBtn.addEventListener('click', () => {
  // Reset burette volume
  burSlider.value = '0';
  updateBuretteUI();
  drawPHGraph();

  // Close the tap
  updateTapVisual(0);

  // Reset flow rate slider to default (8 drops/s)
  flowSlider.value = 8;
  updateFlowLabel();
});


// React to slider & indicator changes
burSlider.addEventListener('input', () => { updateBuretteUI(); drawPHGraph(); });
indSelect.addEventListener('change', () => { updateBuretteUI(); drawPHGraph(); });
// Concentration controls (acid/base/flask volume & source toggle)
[concAcid, concBase, flaskVol, useConcEP].forEach(el => {
  el.addEventListener('input', applyEndpoint);
  el.addEventListener('change', applyEndpoint);
});

// React to slider & indicator changes
burSlider.addEventListener('input', () => { updateBuretteUI(); drawPHGraph(); });
indSelect.addEventListener('change', () => { updateBuretteUI(); drawPHGraph(); });

// Concentration controls (acid/base/flask volume & source toggle)
[concAcid, concBase, flaskVol, useConcEP].forEach(el => {
  el.addEventListener('input', applyEndpoint);
  el.addEventListener('change', applyEndpoint);
});

// If the endpoint (mean) changes later, re-read it
const meanEl = document.getElementById('tit-mean');
if (meanEl) {
  const obs = new MutationObserver(() => {
    if (!useConcEP.checked) {
      ENDPOINT = getEndpoint();
      if (endOut) endOut.textContent = ENDPOINT.toFixed(2);
      updateBuretteUI();
      drawPHGraph();
    }
  });
  obs.observe(meanEl, { childList: true });
}

// Initial paint
applyEndpoint();        // sets ENDPOINT from concs (or mean if unchecked) and updates UI
updateBuretteUI();
updateTapVisual(parseInt(flowSlider?.value || 0, 10));
drawPHGraph();          // draws initial pH‚Äìvolume curve + marker

// Create a ripple inside the flask at viewport coords (x,y)
// Create a ripple at viewport coords (x,y) ‚Äî append to <body>, not SVG
function spawnRipple(x, y) {
  const rip = document.createElement('div');
  rip.className = 'ripple';
  rip.style.position = 'fixed';
  rip.style.left = x + 'px';
  rip.style.top  = y + 'px';
  document.body.appendChild(rip);
  setTimeout(() => rip.remove(), 650);
}

// Keep stream aligned if window resizes
window.addEventListener('resize', () => {
  if (streamEl && streamEl.style.opacity === '1') positionStream();
});
</script>
</body>
</html>
