<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mole Master & Titration Lab Wireframes</title>
<style>
body { font-family: Arial, sans-serif; background: #f7f7f7; margin: 20px; }
.tool { background: white; border-radius: 12px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 40px; padding: 20px; }
h2 { margin-top: 0; color: #003366; }
.section { margin: 20px 0; }
.box { border: 2px dashed #aaa; border-radius: 8px; padding: 15px; margin: 10px 0; background: #fafafa; }
.slider { background: #eee; height: 20px; border-radius: 10px; margin: 10px 0; position: relative; }
.slider::after { content: "‚óâ"; position: absolute; left: 40%; top: -5px; }
.table { border-collapse: collapse; width: 100%; margin-top: 10px; }
.table th, .table td { border: 1px solid #ddd; padding: 8px; text-align: center; }
.teacher-controls { background: #eef6ff; border: 1px solid #99c2ff; padding: 10px; margin-top: 15px; border-radius: 6px; }
.graph { border: 2px dotted #666; height: 150px; border-radius: 6px; text-align: center; line-height: 150px; color: #999; }
/* --- Titration visuals --- */
.bench { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
.panel { flex: 1 1 320px; background:#fafafa; border:2px dashed #aaa; border-radius:8px; padding:12px; }

.burette-wrap { position:relative; height:260px; width:80px; margin:6px auto; border:2px solid #999; border-radius:6px; background:linear-gradient(#e9f3ff,#ffffff); }
.burette-scale { position:absolute; left:8px; top:6px; bottom:6px; width:10px; background:repeating-linear-gradient(to bottom, transparent 0 18px, #999 18px 19px); opacity:.7; }
.burette-fill { position:absolute; right:0; bottom:0; width:100%; background:#cfe3ff; border-bottom-left-radius:4px; border-bottom-right-radius:4px; }

.burette-tap { position:absolute; bottom:-16px; left:50%; transform:translateX(-50%); width:14px; height:14px; background:#666; border-radius:50%; }
.burette-spout { position:absolute; bottom:-22px; left:50%; transform:translateX(-50%); width:2px; height:20px; background:#666; }

.flask { position:relative; width:240px; height:200px; margin:10px auto; border:2px solid #666; border-radius:0 0 140px 140px / 0 0 60% 60%; overflow:hidden; background:#fff; }
.liquid { position:absolute; left:0; right:0; bottom:0; height:35%; background:#ffd; transition:background-color .35s ease, height .35s ease; }
.endpoint-bar { height:10px; background:repeating-linear-gradient(90deg,#ccc 0 10px,#eee 10px 20px); border-radius:6px; margin:8px 0; }
.dot { display:inline-block; min-width:12px; min-height:12px; border-radius:50%; border:1px solid #999; vertical-align:middle; margin-right:6px; }

/* Drop now uses viewport coordinates and flies from spout to flask */
.drop {
  position: fixed;         /* positioned relative to the viewport */
  width: 10px;
  height: 14px;
  background: #cfe3ff;
  border-radius: 50% 50% 60% 60%/50% 50% 70% 70%;
  pointer-events: none;
  z-index: 9999;
  opacity: 1;
  transform: translate(-50%, -50%);
  transition: top 0.7s linear, left 0.7s linear, opacity 0.2s ease-out;
}


.readout { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#fff; border:1px solid #ddd; padding:4px 8px; border-radius:6px; display:inline-block; }
.ctrl-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
/* --- Impact ripple in the flask --- */
.ripple {
  position: absolute;            /* lives inside the flask (clipped) */
  width: 6px; height: 6px;
  border: 2px solid rgba(0,0,0,0.18);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0.2);
  pointer-events: none;
  animation: ripple 0.6s ease-out forwards;
}
@keyframes ripple {
  to { transform: translate(-50%, -50%) scale(3.6); opacity: 0; }
}
/* Continuous stream from spout to liquid */
.stream {
  position: fixed;      /* viewport coords like .drop */
  width: 6px;
  background: linear-gradient(to bottom, rgba(180,210,255,0.9), rgba(180,210,255,0.4));
  border-radius: 3px;
  pointer-events: none;
  z-index: 9998;
  opacity: 0;
  transition: opacity .15s ease;
}
 /* --- Tap animation (open/close) --- */
.burette-tap {
  transition: transform .18s ease;        /* smooth rotate */
}

/* add a little handle on the tap to make movement obvious */
.burette-tap::after {
  content: "";
  position: absolute;
  left: 50%;
  top: 4px;
  width: 24px;           /* handle length */
  height: 6px;
  border-radius: 3px;
  background: #5a5a5a;
  transform-origin: left center;
  transform: translateX(-50%);
}

/* spout gets a bit thicker when tap is open */
.burette-spout {
  transition: width .18s ease, opacity .18s ease;
}
 
</style>
</head>
<body>


<!-- Mole Master -->
<div class="tool">
<h2>Wireframe: Mole Master</h2>


<div class="section">
<h3>Equation Input</h3>
<label for="mm-eq">Type an equation:</label>
<input id="mm-eq" value="H2 + O2 -> H2O" style="width: 60%; max-width: 480px;">
<button id="mm-balance-btn">Auto-balance</button>
<div id="mm-balance-result" class="box" style="margin-top:8px;">Balanced equation will appear here‚Ä¶</div>
That gives you:


<div class="section">
<h3>Recipe View</h3>
<div class="box">
- Bars for moles / mass / volume<br>
- Visual ‚Äúcake recipe‚Äù layout
</div>
</div>


<div class="section">
<h3>Adjust Quantities</h3>
<div>
  <label>Reactant amount (g): <b id="mm-reactant-val">50</b></label><br>
  <input id="mm-reactant" type="range" min="0" max="100" value="50" step="1" style="width:100%;">
</div>
<div style="margin-top:10px;">
  <label>Product target (g): <b id="mm-product-val">40</b></label><br>
  <input id="mm-product" type="range" min="0" max="100" value="40" step="1" style="width:100%;">
</div>
<div id="mm-limit-msg" class="box" style="margin-top:10px;">
  Move the sliders. I‚Äôll tell you which side is limiting.
</div>
<div class="box">Dynamic bar charts update ‚Üí Limiting Reactant Highlighted</div>
</div>


<div class="section teacher-controls">
<h3>Teacher Controls</h3>
- Lock inputs (mass, conc)<br>
- Add uncertainty overlay<br>
- Export as CSV
</div>


<div class="section">
<h3>Output</h3>
<div class="box">[ Results panel: Leftover, % yield, Atom economy ]</div>
</div>
</div>


<!-- Titration Lab -->
<div class="tool">
<h2>Wireframe: Titration Lab</h2>


<div class="section">
<h3>Lab Bench View</h3>
<div class="box">
[ Burette graphic (left) ] ‚Üí [ Conical flask on white tile (centre) ] ‚Üí [ Pipette control (right) ]<br>
Indicator dropdown: Phenolphthalein / Methyl Orange / Litmus
</div>
</div>


<div class="section">
<h3>Run Titration</h3>

<div class="bench">
  <!-- Left: Burette & controls -->
  <div class="panel" style="max-width:360px;">
    <div><b>Indicator:</b>
      <select id="ind-select">
        <option value="phenolphthalein" selected>Phenolphthalein (pink ‚Üí colourless)</option>
        <option value="methylorange">Methyl orange (red ‚Üí orange ‚Üí yellow)</option>
      </select>
    </div>

    <div class="endpoint-bar" title="Endpoint marker"></div>

    <div class="ctrl-row" style="margin:6px 0;">
      <span class="dot" id="dot-color" style="background:#ffc0de;"></span>
      Flask colour ‚Ä¢ pH (approx): <span class="readout" id="ph-read">~13</span>
    </div>

    <div class="burette-wrap">
      <div class="burette-scale"></div>
      <div class="burette-fill" id="bur-fill" style="height: 85%;"></div>
      <div class="burette-tap"></div>
      <div class="burette-spout"></div>
      <!-- falling drops will be injected here -->
    </div>

    <div style="margin-top:8px;">
      <label for="bur-vol"><b>Burette volume added</b> (cm¬≥): <span class="readout" id="bur-vol-out">0.00</span></label>
      <input id="bur-vol" type="range" min="0" max="30" value="0" step="0.05" style="width:100%;">
    </div>

    <div class="ctrl-row" style="margin-top:6px;">
      <button id="drip-1">Drip 1 drop (‚âà0.05 cm¬≥)</button>
      <button id="drip-hold">Hold to drip</button>
      <button id="reset-bur">Reset</button>
      <span>Endpoint (from table mean): <span class="readout" id="endpoint-out">‚Äî</span> cm¬≥</span>
    </div>
    
  </div>
  <div class="ctrl-row" style="margin-top:6px;">
  <label for="flow-rate"><b>Flow rate</b> (drops/s): <span class="readout" id="flow-out">8</span></label>
  <input id="flow-rate" type="range" min="1" max="20" value="8" step="1" style="width:240px;">
</div>

  <!-- Right: Flask visual -->
  <div class="panel" style="max-width:340px; text-align:center;">
    <div><b>Flask (25.0 cm¬≥ base + indicator)</b></div>
    <div class="flask" id="flask">
      <div class="liquid" id="liquid"></div>
    </div>
    <div>Colour at endpoint depends on indicator choice.</div>
  </div>
</div>

<h3>Data Table</h3>
<table class="table" id="tit-table">
  <tr><th>Trial</th><th>Initial (cm¬≥)</th><th>Final (cm¬≥)</th><th>Titre (cm¬≥)</th></tr>
  <tr>
    <td>Rough</td>
    <td><input value="0.00" class="tit-in" data-row="0" data-type="init"></td>
    <td><input value="23.80" class="tit-in" data-row="0" data-type="final"></td>
    <td id="tit-titre-0">23.80</td>
  </tr>
  <tr>
    <td>1</td>
    <td><input value="0.00" class="tit-in" data-row="1" data-type="init"></td>
    <td><input value="23.40" class="tit-in" data-row="1" data-type="final"></td>
    <td id="tit-titre-1">23.40</td>
  </tr>
  <tr>
    <td>2</td>
    <td><input value="0.00" class="tit-in" data-row="2" data-type="init"></td>
    <td><input value="23.50" class="tit-in" data-row="2" data-type="final"></td>
    <td id="tit-titre-2">23.50</td>
  </tr>
</table>
<div class="box">Mean (Trials 1 & 2): <b id="tit-mean">23.45</b> cm¬≥</div>
<script>
/* === Mole Master: Auto-balance demo === */
document.getElementById('mm-balance-btn').addEventListener('click', () => {
  const eq = document.getElementById('mm-eq').value.trim().replace(/\s+/g,'');
  const out = document.getElementById('mm-balance-result');
  if (eq === 'H2+O2->H2O' || eq === 'H2+O2=>H2O') {
    out.textContent = '2H‚ÇÇ + O‚ÇÇ ‚Üí 2H‚ÇÇO';
  } else {
    out.textContent = 'This demo only balances water right now üòä Try: H2 + O2 -> H2O';
  }
});

/* === Mole Master sliders === */
const rSlide = document.getElementById('mm-reactant');
const pSlide = document.getElementById('mm-product');
const rVal = document.getElementById('mm-reactant-val');
const pVal = document.getElementById('mm-product-val');
const limitMsg = document.getElementById('mm-limit-msg');
function updateMM() {
  rVal.textContent = rSlide.value;
  pVal.textContent = pSlide.value;
  const r = Number(rSlide.value), p = Number(pSlide.value);
  if (r === 0 && p === 0) limitMsg.textContent = 'Both are zero ‚Äî nothing will happen yet!';
  else if (r === p) limitMsg.textContent = 'Perfectly matched ‚Äî no leftovers üéâ';
  else if (r < p) limitMsg.textContent = 'Reactant is limiting (you need more reactant to hit that product target).';
  else limitMsg.textContent = 'Product target is low ‚Äî you will have leftover reactant.';
}
rSlide.addEventListener('input', updateMM);
pSlide.addEventListener('input', updateMM);
updateMM();

/* === Titration: auto-calc titres & mean === */
function twoDp(x){ return Number(x).toFixed(2); }
function recalcTitration() {
  for (let row = 0; row <= 2; row++) {
    const init = document.querySelector(`.tit-in[data-row="${row}"][data-type="init"]`).value;
    const fin  = document.querySelector(`.tit-in[data-row="${row}"][data-type="final"]`).value;
    const titre = twoDp(Number(fin) - Number(init));
    document.getElementById(`tit-titre-${row}`).textContent = titre;
  }
  const t1 = parseFloat(document.getElementById('tit-titre-1').textContent);
  const t2 = parseFloat(document.getElementById('tit-titre-2').textContent);
  document.getElementById('tit-mean').textContent = twoDp((t1 + t2) / 2);
}
document.querySelectorAll('.tit-in').forEach(inp => {
  inp.addEventListener('input', recalcTitration);
});
recalcTitration();
/* ===== Titration: burette drip + colour-changing flask ===== */

// Grab controls
const burSlider = document.getElementById('bur-vol');
const burOut = document.getElementById('bur-vol-out');
const burFill = document.getElementById('bur-fill');
const flask = document.getElementById('flask');
const liquid = document.getElementById('liquid');
const endOut = document.getElementById('endpoint-out');
const phOut = document.getElementById('ph-read');
const dotColor = document.getElementById('dot-color');
const dripBtn = document.getElementById('drip-1');
const resetBtn = document.getElementById('reset-bur');
const indSelect = document.getElementById('ind-select');
const flowSlider = document.getElementById('flow-rate');
const flowOut = document.getElementById('flow-out');
// --- flow / pour constants ---
const CONT_THRESHOLD = 15;   // ‚â• this rate = continuous stream
const BASE_STEP = 0.05;      // ~0.05 cm¬≥ per ‚Äúdrop‚Äù at low flow

// --- continuous pour support ---
let streamEl = null;  // the DOM element for the visible stream
let pourRAF = null;   // requestAnimationFrame handle while pouring

// Use the mean from your table as the endpoint (nice link!)
function getEndpoint() {
  const el = document.getElementById('tit-mean');
  const v = el ? parseFloat(el.textContent) : 23.50;
  return isFinite(v) ? v : 23.50;
}

let ENDPOINT = getEndpoint();
endOut.textContent = ENDPOINT.toFixed(2);

// Simple pH approximation for strong acid/strong base titration curve.
// We just want the "S-shape" to teach the idea; not lab-accurate.
function approxPH(added) {
  // Map 0..(2*endpoint) into ~13..1 with a steep switch around endpoint
  const e = ENDPOINT;
  const x = (added - e) / (e * 0.08);  // 8% of endpoint makes a steep region
  const sig = 1 / (1 + Math.exp(-x));  // 0..1
  const ph = 13 - sig * 12;            // ~13 high, ~1 low
  return Math.max(1, Math.min(13, ph));
}
function updateFlowLabel() {
  if (!flowSlider) return;
  flowOut.textContent = flowSlider.value;
}
updateFlowLabel();
flowSlider.addEventListener('input', updateFlowLabel);
function updateTapVisual(rate) {
  const tap = document.querySelector('.burette-tap');
  const spout = document.querySelector('.burette-spout');
  if (!tap || !spout) return;

  // Map rate (1..20) to angle (0..85¬∞). Below ~1 = closed.
  const r = Math.max(0, Math.min(20, parseInt(rate || 0, 10)));
  const angle = (r / 20) * 85;                      // degrees

  // Keep existing translateX(-50%) and add rotate()
  tap.style.transform = `translateX(-50%) rotate(${angle}deg)`;

  // Spout looks "more open" with slightly larger width and higher opacity
  const w = 2 + (r / 20) * 3;                       // 2px ‚Üí 5px
  spout.style.width = `${w}px`;
  spout.style.opacity = r > 0 ? 1 : 0.8;
}

// Colour model per indicator
function colourForIndicator(ph, indicator) {
  if (indicator === 'phenolphthalein') {
    // Pink above ~8.2, colourless below ~8.2
    if (ph >= 10.0) return { bg:'#ffc0de', dot:'#ffc0de' };        // strong pink
    if (ph >= 8.2)  return { bg:'#ffe0ee', dot:'#ffd2e6' };        // pale pink
    return { bg:'#f7f7f7', dot:'#f7f7f7' };                        // colourless
  } else {
    // Methyl orange: red (<3.1), orange (3.1..4.4), yellow (>4.4)
    if (ph < 3.1)   return { bg:'#ffb3a8', dot:'#ff8f80' };        // red-ish
    if (ph < 4.4)   return { bg:'#ffd19a', dot:'#ffb347' };        // orange
    return { bg:'#fff7a6', dot:'#ffe34d' };                        // yellow
  }
}

// Update the whole visual state
function updateBuretteUI() {
  const v = parseFloat(burSlider.value);
  burOut.textContent = v.toFixed(2);

  // Burette fill: 0 cm¬≥ added = full, max = emptier
  const max = parseFloat(burSlider.max);
  const fillPct = Math.max(0, 100 - (v / max) * 100);
  burFill.style.height = fillPct + '%';

  // Liquid height grows a little as you add volume (looks lively)
  const baseHeight = 35; // %
  const extra = Math.min(20, (v / ENDPOINT) * 20);
  liquid.style.height = (baseHeight + extra) + '%';

  // pH & colour
  const ph = approxPH(v);
  phOut.textContent = '~' + ph.toFixed(1);
  const col = colourForIndicator(ph, indSelect.value);
  liquid.style.backgroundColor = col.bg;
  dotColor.style.backgroundColor = col.dot;
}
  // Create the (single) stream element if needed
function ensureStreamEl() {
  if (streamEl) return streamEl;
  streamEl = document.createElement('div');
  streamEl.className = 'stream';
  document.body.appendChild(streamEl);
  return streamEl;
}

// Position the stream from the spout tip down to the current liquid surface
function positionStream() {
  const spout = document.querySelector('.burette-spout');
  const flaskEl = document.getElementById('flask');
  const liquidEl = document.getElementById('liquid');
  if (!spout || !flaskEl || !liquidEl) return;

  const sp = spout.getBoundingClientRect();
  const liq = liquidEl.getBoundingClientRect();

  const x = sp.left + sp.width / 2;
  const yTop = sp.bottom;
  const yBottom = liq.top;

  const el = ensureStreamEl();
  el.style.left = `${x - 3}px`;                  // center a 6px wide stream
  el.style.top = `${yTop}px`;
  el.style.height = `${Math.max(6, yBottom - yTop)}px`;
}

// Show/hide the stream with a quick fade
function showStream(show) {
  ensureStreamEl();
  positionStream();
  streamEl.style.opacity = show ? 1 : 0;
}

// Create a falling drop animation
function spawnDrop(step = 0.05) {
  // Elements we need
  const spout = document.querySelector('.burette-spout');
  const flaskEl = document.getElementById('flask');
  const liquidEl = document.getElementById('liquid');
  if (!spout || !flaskEl || !liquidEl) return;

  // Viewport positions
  const sp = spout.getBoundingClientRect();
  const fl = flaskEl.getBoundingClientRect();
  const liq = liquidEl.getBoundingClientRect();

  // Start (spout tip) and end (liquid surface centre)
  const startX = sp.left + sp.width / 2;
  const startY = sp.bottom;
  const targetX = fl.left + fl.width / 2;
  const targetY = liq.top;

  // Make the drop anywhere on the page
  const drop = document.createElement('div');
  drop.className = 'drop';
  document.body.appendChild(drop);
  
  // Scale drop size with step (so big glugs look larger)
  const size = Math.min(22, 8 + step * 200); // ~8px at low flow, up to ~22px
  drop.style.width = size + 'px';
  drop.style.height = (size * 1.3) + 'px';
  
  // Start at spout
  drop.style.left = `${startX}px`;
  drop.style.top  = `${startY}px`;

  // Next frame: fly to liquid surface
  requestAnimationFrame(() => {
    drop.style.left = `${targetX}px`;
    drop.style.top  = `${targetY - 2}px`; // slight overlap
  });

  // When the flight finishes: make a ripple, then fade/remove the drop
  drop.addEventListener('transitionend', () => {
    // >>> THIS is the new line for 3B:
    spawnRipple(targetX, targetY);

    drop.style.opacity = '0';
    setTimeout(() => drop.remove(), 200);
  }, { once: true });
}



// Buttons
dripBtn.addEventListener('click', () => {
  const step = parseFloat(burSlider.step) || 0.05;
  const newV = Math.min(parseFloat(burSlider.max), parseFloat(burSlider.value) + step);
  burSlider.value = newV.toString();
  spawnDrop();
  updateBuretteUI();
});
// Hold-to-drip: press and hold to drip repeatedly
const holdBtn = document.getElementById('drip-hold');
let dripTimer = null;

function dripOnce() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);        // drops/sec
  const step = BASE_STEP * (1 + (rate - 1) / 10);                        // bigger glugs at higher rate

  const newV = Math.min(parseFloat(burSlider.max), parseFloat(burSlider.value) + step);
  if (newV === parseFloat(burSlider.value)) return; // at max
  burSlider.value = newV.toString();
  spawnDrop(step);                                                      // pass size for visuals
  updateBuretteUI();
}



// Compute + set the interval from the current flow rate
function setDripIntervalFromRate() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8); // drops/sec
  const period = 1000 / rate; // ms per drop
  if (dripTimer) clearInterval(dripTimer);
  dripTimer = setInterval(dripOnce, period);
}

function startHold() {
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);
  updateTapVisual(rate);
  // High flow ‚Üí continuous stream using requestAnimationFrame
  if (rate >= CONT_THRESHOLD) {
    if (pourRAF) return;            // already pouring
    showStream(true);

    let last = performance.now();
    const stepPerDrop = BASE_STEP * (1 + (rate - 1) / 10);
    const dropsPerSec = rate;

    const tick = (now) => {
      const dt = (now - last) / 1000;   // seconds since last frame
      last = now;

      // Volume increment this frame
      const dv = dropsPerSec * stepPerDrop * dt;
      const vNow = parseFloat(burSlider.value);
      const vMax = parseFloat(burSlider.max);
      const vNew = Math.min(vMax, vNow + dv);

      burSlider.value = vNew.toFixed(3);
      updateBuretteUI();

      // Keep the stream aligned to spout ‚Üí liquid (with tiny jitter)
      positionStream();
      if (streamEl) {
        const j = (Math.random() - 0.5) * 2; // ¬±1 px wobble
        streamEl.style.transform = `translateX(${j}px)`;
      }

      if (vNew >= vMax || !pourRAF) {
        stopHold();                   // stop if maxed or cancelled
        return;
      }
      pourRAF = requestAnimationFrame(tick);
    };

    pourRAF = requestAnimationFrame(tick);
    return;
  }

  // Low/medium flow ‚Üí discrete drops via interval
  setDripIntervalFromRate();
}

function stopHold() {
  // stop timers/RAF ...
  if (dripTimer) { clearInterval(dripTimer); dripTimer = null; }
  if (pourRAF) { cancelAnimationFrame(pourRAF); pourRAF = null; }
  showStream(false);

  updateTapVisual(0);                   // <--- closes the tap
}


// Mouse + touch support
holdBtn.addEventListener('mousedown', startHold);
holdBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); }, { passive: false });
['mouseup','mouseleave','touchend','touchcancel'].forEach(ev => {
  holdBtn.addEventListener(ev, stopHold);
});

// If the flow slider changes while holding, retune the interval live
flowSlider.addEventListener('input', () => {
  updateFlowLabel();
  const rate = Math.max(1, parseInt(flowSlider.value, 10) || 8);
  updateTapVisual(rate);                // <--- add this line

  // If we're currently holding (either mode), switch modes on the fly
  if (dripTimer || pourRAF) {
    stopHold();
    startHold();
  }
});



resetBtn.addEventListener('click', () => {
  burSlider.value = '0';
  updateBuretteUI();
  updateTapVisual(0);
});

// React to slider & indicator changes
burSlider.addEventListener('input', updateBuretteUI);
indSelect.addEventListener('change', updateBuretteUI);

// If the endpoint (mean) changes later, re-read it
const meanEl = document.getElementById('tit-mean');
if (meanEl) {
  // Mutation observer so if you edit the table and mean updates, the endpoint follows
  const obs = new MutationObserver(() => {
    ENDPOINT = getEndpoint();
    endOut.textContent = ENDPOINT.toFixed(2);
    updateBuretteUI();
  });
  obs.observe(meanEl, { childList: true });
}

// Initial paint
updateBuretteUI();
updateTapVisual(parseInt(flowSlider?.value || 0, 10));

  // Create a ripple inside the flask at viewport coords (x,y)
function spawnRipple(x, y) {
  const flaskEl = document.getElementById('flask');
  if (!flaskEl) return;
  const fr = flaskEl.getBoundingClientRect();

  // Convert viewport coords to flask-local coords
  const rx = x - fr.left;
  const ry = y - fr.top;

  const rip = document.createElement('div');
  rip.className = 'ripple';
  rip.style.left = rx + 'px';
  rip.style.top  = ry + 'px';
  flaskEl.appendChild(rip);

  // Clean up after animation
  setTimeout(() => rip.remove(), 650);
}
window.addEventListener('resize', () => { if (streamEl && streamEl.style.opacity === '1') positionStream(); });

</script>
</html>
